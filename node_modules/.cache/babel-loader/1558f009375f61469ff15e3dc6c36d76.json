{"ast":null,"code":"import { Subject, from, queueScheduler } from 'rxjs';\nimport { map, mergeMap, observeOn, subscribeOn } from 'rxjs/operators';\nimport { ActionsObservable } from './ActionsObservable';\nimport { StateObservable } from './StateObservable';\nimport { warn } from './utils/console';\nexport function createEpicMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // This isn't great. RxJS doesn't publicly export the constructor for\n  // QueueScheduler nor QueueAction, so we reach in. We need to do this because\n  // we don't want our internal queuing mechanism to be on the same queue as any\n  // other RxJS code outside of redux-observable internals.\n  var QueueScheduler = queueScheduler.constructor;\n  var uniqueQueueScheduler = new QueueScheduler(queueScheduler.SchedulerAction);\n  if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n    throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n  }\n  var epic$ = new Subject();\n  var store = void 0;\n  var epicMiddleware = function epicMiddleware(_store) {\n    if (process.env.NODE_ENV !== 'production' && store) {\n      // https://github.com/redux-observable/redux-observable/issues/389\n      warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n    }\n    store = _store;\n    var actionSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var stateSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var action$ = new ActionsObservable(actionSubject$);\n    var state$ = new StateObservable(stateSubject$, store.getState());\n    var result$ = epic$.pipe(map(function (epic) {\n      var output$ = 'dependencies' in options ? epic(action$, state$, options.dependencies) : epic(action$, state$);\n      if (!output$) {\n        throw new TypeError('Your root Epic \"' + (epic.name || '<anonymous>') + '\" does not return a stream. Double check you\\'re not missing a return statement!');\n      }\n      return output$;\n    }), mergeMap(function (output$) {\n      return from(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));\n    }));\n    result$.subscribe(store.dispatch);\n    return function (next) {\n      return function (action) {\n        // Downstream middleware gets the action first,\n        // which includes their reducers, so state is\n        // updated before epics receive the action\n        var result = next(action);\n\n        // It's important to update the state$ before we emit\n        // the action because otherwise it would be stale\n        stateSubject$.next(store.getState());\n        actionSubject$.next(action);\n        return result;\n      };\n    };\n  };\n  epicMiddleware.run = function (rootEpic) {\n    if (process.env.NODE_ENV !== 'production' && !store) {\n      warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n    }\n    epic$.next(rootEpic);\n  };\n  return epicMiddleware;\n}","map":{"version":3,"names":["Subject","from","queueScheduler","map","mergeMap","observeOn","subscribeOn","ActionsObservable","StateObservable","warn","createEpicMiddleware","options","arguments","length","undefined","QueueScheduler","constructor","uniqueQueueScheduler","SchedulerAction","process","env","NODE_ENV","TypeError","epic$","store","epicMiddleware","_store","actionSubject$","pipe","stateSubject$","action$","state$","getState","result$","epic","output$","dependencies","name","subscribe","dispatch","next","action","result","run","rootEpic"],"sources":["D:/Desktop/sarjanHardware/sarjanHardware/node_modules/redux-observable/lib/esm/createEpicMiddleware.js"],"sourcesContent":["import { Subject, from, queueScheduler } from 'rxjs';\nimport { map, mergeMap, observeOn, subscribeOn } from 'rxjs/operators';\nimport { ActionsObservable } from './ActionsObservable';\nimport { StateObservable } from './StateObservable';\nimport { warn } from './utils/console';\n\nexport function createEpicMiddleware() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // This isn't great. RxJS doesn't publicly export the constructor for\n  // QueueScheduler nor QueueAction, so we reach in. We need to do this because\n  // we don't want our internal queuing mechanism to be on the same queue as any\n  // other RxJS code outside of redux-observable internals.\n  var QueueScheduler = queueScheduler.constructor;\n  var uniqueQueueScheduler = new QueueScheduler(queueScheduler.SchedulerAction);\n\n  if (process.env.NODE_ENV !== 'production' && typeof options === 'function') {\n    throw new TypeError('Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\\n\\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware');\n  }\n\n  var epic$ = new Subject();\n  var store = void 0;\n\n  var epicMiddleware = function epicMiddleware(_store) {\n    if (process.env.NODE_ENV !== 'production' && store) {\n      // https://github.com/redux-observable/redux-observable/issues/389\n      warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\\n\\nLearn more: https://goo.gl/2GQ7Da');\n    }\n    store = _store;\n    var actionSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var stateSubject$ = new Subject().pipe(observeOn(uniqueQueueScheduler));\n    var action$ = new ActionsObservable(actionSubject$);\n    var state$ = new StateObservable(stateSubject$, store.getState());\n\n    var result$ = epic$.pipe(map(function (epic) {\n      var output$ = 'dependencies' in options ? epic(action$, state$, options.dependencies) : epic(action$, state$);\n\n      if (!output$) {\n        throw new TypeError('Your root Epic \"' + (epic.name || '<anonymous>') + '\" does not return a stream. Double check you\\'re not missing a return statement!');\n      }\n\n      return output$;\n    }), mergeMap(function (output$) {\n      return from(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));\n    }));\n\n    result$.subscribe(store.dispatch);\n\n    return function (next) {\n      return function (action) {\n        // Downstream middleware gets the action first,\n        // which includes their reducers, so state is\n        // updated before epics receive the action\n        var result = next(action);\n\n        // It's important to update the state$ before we emit\n        // the action because otherwise it would be stale\n        stateSubject$.next(store.getState());\n        actionSubject$.next(action);\n\n        return result;\n      };\n    };\n  };\n\n  epicMiddleware.run = function (rootEpic) {\n    if (process.env.NODE_ENV !== 'production' && !store) {\n      warn('epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first.');\n    }\n    epic$.next(rootEpic);\n  };\n\n  return epicMiddleware;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}